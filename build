#!/usr/bin/perl
use strict;
use Getopt::Long;
use Pod::Usage;

#####################
# Parameters handling
#####################

my $level = 0;
my $help = 0;
my $man = 0;
my $check_only = 0;

GetOptions('v|verbose' => \$level,
	   'help|?' => \$help,
	    man => \$man,
	   'check_only|check-only' => \$check_only,
	  ) or pod2usage(2);
pod2usage(1) if $help;
pod2usage(-exitstatus => 0, -verbose => 2) if $man;

########################
# Check for missing deps
########################

my @missing;

my $system_release = catcheck("/etc/system-release");
$system_release = catcheck("/etc/redhat-release") if !$system_release;
$system_release = catcheck("/etc/lsb-release") if !$system_release;

sub catcheck($)
{
  my $res = "";
  $res = qx(cat $_[0]) if (-r $_[0]);
  return $res;
}

sub give_redhat_hints()
{
	my $install;

	my %map = (
		"lsdiff"		=> "patchutils",
		"Digest::SHA1"		=> "perl-Digest-SHA1",
		"Proc::ProcessTable"	=> "perl-Proc-ProcessTable",
	);

	foreach my $prog (@missing) {
		print "ERROR: please install \"$prog\", otherwise, build won't work.\n";
		if (defined($map{$prog})) {
			$install .= " " . $map{$prog};
		} else {
			$install .= " " . $prog;
		}
	}

	printf("You should run:\n\tyum install -y $install\n");
}

sub give_ubuntu_hints()
{
	my $install;

	my %map = (
		"lsdiff"		=> "patchutils",
		"Digest::SHA1"		=> "libdigest-sha1-perl",
		"Proc::ProcessTable"	=> "libproc-processtable-perl",
	);

	foreach my $prog (@missing) {
		print "ERROR: please install \"$prog\", otherwise, build won't work.\n";
		if (defined($map{$prog})) {
			$install .= " " . $map{$prog};
		} else {
			$install .= " " . $prog;
		}
	}

	printf("You should run:\n\tsudo apt-get install $install\n");
}

sub give_hints()
{

	# Distro-specific hints
	if ($system_release =~ /Red Hat Enterprise Linux Workstation/) {
		give_redhat_hints;
		return;
	}
	if ($system_release =~ /Fedora/) {
		give_redhat_hints;
		return;
	}
	if ($system_release =~ /Ubuntu/) {
		give_ubuntu_hints;
		return;
	}

	# Fall-back to generic hint code
	foreach my $prog (@missing) {
		print "ERROR: please install \"$prog\", otherwise, build won't work.\n";
	}
	print "I don't know distro $system_release. So, I can't provide you a hint with the package names.\n";
	print "Be welcome to contribute with a patch for media-build, by submitting a distro-specific hint\n";
	print "to linux-media\@vger.kernel.org\n";
}

my $need = 0;
sub findprog($)
{
	foreach(split(/:/, $ENV{PATH})) {
		return "$_/$_[0]" if(-x "$_/$_[0]");
	}
}

sub need_program($)
{
	my $prog = shift;

	return if findprog($prog);

	push @missing, $prog;

	$need++;
}

sub need_perl_module($)
{
	my $prog = shift;

	my $err = system("perl -M$prog -e 1 2>/dev/null /dev/null");
	return if ($err == 0);

	push @missing, $prog;

	$need++;
}

sub check_needs()
{
	print "Checking if the needed tools are present:\n";

	# Check for needed programs/tools
	need_program "git";
	need_program "make";
	need_program "gcc";
	need_program "patch";
	need_program "lsdiff";

	# Check for needed perl modules
	need_perl_module "Digest::SHA1";
	need_perl_module "Proc::ProcessTable";

	give_hints if ($need);

	die "Build can't procceed as $need dependency is missing" if ($need == 1);
	die "Build can't procceed as $need dependencies are missing" if ($need);

	print "Needed package dependencies are met.\n";
}

######
# Main
######

check_needs;

exit (0) if ($check_only);

print "\n";
print "************************************************************\n";
print "* This script will download the latest tarball and build it*\n";
print "* Assuming that your kernel is compatible with the latest  *\n";
print "* drivers. If not, you'll need to add some extra backports,*\n";
print "* ./backports/<kernel> directory.                          *\n";
print "* It will also update this tree to be sure that all compat *\n";
print "* bits are there, to avoid compilation failures            *\n";
print "************************************************************\n";
print "\n";

sleep 5;

print "****************************\n";
print "Updating the building system\n";
print "****************************\n";
system("git pull git://linuxtv.org/media_build.git master");

system ("make -C linux/ download") == 0 or die "Download failed";
system ("make -C linux/ untar") == 0 or die "Untar failed";
system ("make") == 0 or die "build failed";

print "**********************************************************\n";
print "* Compilation finished. Use 'make install' to install them\n";
print "**********************************************************\n";


__END__

=head1 NAME

build - Builds the media drivers without needing to compile a new kernel

=head1 SYNOPSIS

build [options]

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=item B<--verbose>

Be more verbose.

=item B<--check_only>

Don't do anything, except for checking if the needed dependencies are there.

=back

=head1 DESCRIPTION

B<build> will download and compile the latest drivers from linuxtv.org,
allowing testing them before reaching the upstream kernels.

This is an experimental build system for media drivers.
All files on this tree are covered by GPLv2, as stated at COPYING file.

Usage:

Just call the build utility:
	$ ./build

Then, install the drivers as root, with:
	# make install

In order to test, unload old drivers with:
	# make rmmod

Then modprobe the driver you want to test. For example:
	# modprobe bttv

=head1 BUGS

Report bugs to Mauro Carvalho Chehab <mchehab@redhat.com>

=head1 COPYRIGHT

Copyright (c) 2011 by Mauro Carvalho Chehab <mchehab@redhat.com>.

License GPLv2: GNU GPL version 2 <http://gnu.org/licenses/gpl.html>.

This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

=cut
